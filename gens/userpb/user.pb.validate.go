// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: proto/user/user.proto

package userpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on AuthenticatorEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthenticatorEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthenticatorEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthenticatorEventMultiError, or nil if none found.
func (m *AuthenticatorEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthenticatorEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Authenticator

	// no validation rules for Event

	if len(errors) > 0 {
		return AuthenticatorEventMultiError(errors)
	}

	return nil
}

// AuthenticatorEventMultiError is an error wrapping multiple validation errors
// returned by AuthenticatorEvent.ValidateAll() if the designated constraints
// aren't met.
type AuthenticatorEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthenticatorEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthenticatorEventMultiError) AllErrors() []error { return m }

// AuthenticatorEventValidationError is the validation error returned by
// AuthenticatorEvent.Validate if the designated constraints aren't met.
type AuthenticatorEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthenticatorEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthenticatorEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthenticatorEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthenticatorEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthenticatorEventValidationError) ErrorName() string {
	return "AuthenticatorEventValidationError"
}

// Error satisfies the builtin error interface
func (e AuthenticatorEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthenticatorEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthenticatorEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthenticatorEventValidationError{}

// Validate checks the field values on RegisterBeginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterBeginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterBeginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterBeginRequestMultiError, or nil if none found.
func (m *RegisterBeginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterBeginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RegisterBeginRequestMultiError(errors)
	}

	return nil
}

// RegisterBeginRequestMultiError is an error wrapping multiple validation
// errors returned by RegisterBeginRequest.ValidateAll() if the designated
// constraints aren't met.
type RegisterBeginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterBeginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterBeginRequestMultiError) AllErrors() []error { return m }

// RegisterBeginRequestValidationError is the validation error returned by
// RegisterBeginRequest.Validate if the designated constraints aren't met.
type RegisterBeginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterBeginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterBeginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterBeginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterBeginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterBeginRequestValidationError) ErrorName() string {
	return "RegisterBeginRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterBeginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterBeginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterBeginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterBeginRequestValidationError{}

// Validate checks the field values on RegisterBeginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterBeginResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterBeginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterBeginResponseMultiError, or nil if none found.
func (m *RegisterBeginResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterBeginResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterBeginResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterBeginResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterBeginResponseValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BizId

	for idx, item := range m.GetNeededOrEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RegisterBeginResponseValidationError{
						field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RegisterBeginResponseValidationError{
						field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RegisterBeginResponseValidationError{
					field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RegisterBeginResponseMultiError(errors)
	}

	return nil
}

// RegisterBeginResponseMultiError is an error wrapping multiple validation
// errors returned by RegisterBeginResponse.ValidateAll() if the designated
// constraints aren't met.
type RegisterBeginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterBeginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterBeginResponseMultiError) AllErrors() []error { return m }

// RegisterBeginResponseValidationError is the validation error returned by
// RegisterBeginResponse.Validate if the designated constraints aren't met.
type RegisterBeginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterBeginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterBeginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterBeginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterBeginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterBeginResponseValidationError) ErrorName() string {
	return "RegisterBeginResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterBeginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterBeginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterBeginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterBeginResponseValidationError{}

// Validate checks the field values on RegisterCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterCheckRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterCheckRequestMultiError, or nil if none found.
func (m *RegisterCheckRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterCheckRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetBizId()) < 1 {
		err := RegisterCheckRequestValidationError{
			field:  "BizId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RegisterCheckRequestMultiError(errors)
	}

	return nil
}

// RegisterCheckRequestMultiError is an error wrapping multiple validation
// errors returned by RegisterCheckRequest.ValidateAll() if the designated
// constraints aren't met.
type RegisterCheckRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterCheckRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterCheckRequestMultiError) AllErrors() []error { return m }

// RegisterCheckRequestValidationError is the validation error returned by
// RegisterCheckRequest.Validate if the designated constraints aren't met.
type RegisterCheckRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterCheckRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterCheckRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterCheckRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterCheckRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterCheckRequestValidationError) ErrorName() string {
	return "RegisterCheckRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterCheckRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterCheckRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterCheckRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterCheckRequestValidationError{}

// Validate checks the field values on RegisterCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterCheckResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterCheckResponseMultiError, or nil if none found.
func (m *RegisterCheckResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterCheckResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterCheckResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterCheckResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterCheckResponseValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetNeededOrEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RegisterCheckResponseValidationError{
						field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RegisterCheckResponseValidationError{
						field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RegisterCheckResponseValidationError{
					field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RegisterCheckResponseMultiError(errors)
	}

	return nil
}

// RegisterCheckResponseMultiError is an error wrapping multiple validation
// errors returned by RegisterCheckResponse.ValidateAll() if the designated
// constraints aren't met.
type RegisterCheckResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterCheckResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterCheckResponseMultiError) AllErrors() []error { return m }

// RegisterCheckResponseValidationError is the validation error returned by
// RegisterCheckResponse.Validate if the designated constraints aren't met.
type RegisterCheckResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterCheckResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterCheckResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterCheckResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterCheckResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterCheckResponseValidationError) ErrorName() string {
	return "RegisterCheckResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterCheckResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterCheckResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterCheckResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterCheckResponseValidationError{}

// Validate checks the field values on RegisterEndRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterEndRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterEndRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterEndRequestMultiError, or nil if none found.
func (m *RegisterEndRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterEndRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetBizId()) < 1 {
		err := RegisterEndRequestValidationError{
			field:  "BizId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RegisterEndRequestMultiError(errors)
	}

	return nil
}

// RegisterEndRequestMultiError is an error wrapping multiple validation errors
// returned by RegisterEndRequest.ValidateAll() if the designated constraints
// aren't met.
type RegisterEndRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterEndRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterEndRequestMultiError) AllErrors() []error { return m }

// RegisterEndRequestValidationError is the validation error returned by
// RegisterEndRequest.Validate if the designated constraints aren't met.
type RegisterEndRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterEndRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterEndRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterEndRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterEndRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterEndRequestValidationError) ErrorName() string {
	return "RegisterEndRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterEndRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterEndRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterEndRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterEndRequestValidationError{}

// Validate checks the field values on RegisterEndResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterEndResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterEndResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterEndResponseMultiError, or nil if none found.
func (m *RegisterEndResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterEndResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterEndResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterEndResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterEndResponseValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserId

	// no validation rules for Token

	if len(errors) > 0 {
		return RegisterEndResponseMultiError(errors)
	}

	return nil
}

// RegisterEndResponseMultiError is an error wrapping multiple validation
// errors returned by RegisterEndResponse.ValidateAll() if the designated
// constraints aren't met.
type RegisterEndResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterEndResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterEndResponseMultiError) AllErrors() []error { return m }

// RegisterEndResponseValidationError is the validation error returned by
// RegisterEndResponse.Validate if the designated constraints aren't met.
type RegisterEndResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterEndResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterEndResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterEndResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterEndResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterEndResponseValidationError) ErrorName() string {
	return "RegisterEndResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterEndResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterEndResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterEndResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterEndResponseValidationError{}

// Validate checks the field values on LoginBeginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LoginBeginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginBeginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginBeginRequestMultiError, or nil if none found.
func (m *LoginBeginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginBeginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return LoginBeginRequestMultiError(errors)
	}

	return nil
}

// LoginBeginRequestMultiError is an error wrapping multiple validation errors
// returned by LoginBeginRequest.ValidateAll() if the designated constraints
// aren't met.
type LoginBeginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginBeginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginBeginRequestMultiError) AllErrors() []error { return m }

// LoginBeginRequestValidationError is the validation error returned by
// LoginBeginRequest.Validate if the designated constraints aren't met.
type LoginBeginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginBeginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginBeginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginBeginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginBeginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginBeginRequestValidationError) ErrorName() string {
	return "LoginBeginRequestValidationError"
}

// Error satisfies the builtin error interface
func (e LoginBeginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginBeginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginBeginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginBeginRequestValidationError{}

// Validate checks the field values on LoginBeginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoginBeginResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginBeginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginBeginResponseMultiError, or nil if none found.
func (m *LoginBeginResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginBeginResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginBeginResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginBeginResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginBeginResponseValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BizId

	for idx, item := range m.GetNeededOrEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LoginBeginResponseValidationError{
						field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LoginBeginResponseValidationError{
						field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoginBeginResponseValidationError{
					field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LoginBeginResponseMultiError(errors)
	}

	return nil
}

// LoginBeginResponseMultiError is an error wrapping multiple validation errors
// returned by LoginBeginResponse.ValidateAll() if the designated constraints
// aren't met.
type LoginBeginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginBeginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginBeginResponseMultiError) AllErrors() []error { return m }

// LoginBeginResponseValidationError is the validation error returned by
// LoginBeginResponse.Validate if the designated constraints aren't met.
type LoginBeginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginBeginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginBeginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginBeginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginBeginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginBeginResponseValidationError) ErrorName() string {
	return "LoginBeginResponseValidationError"
}

// Error satisfies the builtin error interface
func (e LoginBeginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginBeginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginBeginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginBeginResponseValidationError{}

// Validate checks the field values on LoginCheckRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LoginCheckRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginCheckRequestMultiError, or nil if none found.
func (m *LoginCheckRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginCheckRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetBizId()) < 1 {
		err := LoginCheckRequestValidationError{
			field:  "BizId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return LoginCheckRequestMultiError(errors)
	}

	return nil
}

// LoginCheckRequestMultiError is an error wrapping multiple validation errors
// returned by LoginCheckRequest.ValidateAll() if the designated constraints
// aren't met.
type LoginCheckRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginCheckRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginCheckRequestMultiError) AllErrors() []error { return m }

// LoginCheckRequestValidationError is the validation error returned by
// LoginCheckRequest.Validate if the designated constraints aren't met.
type LoginCheckRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginCheckRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginCheckRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginCheckRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginCheckRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginCheckRequestValidationError) ErrorName() string {
	return "LoginCheckRequestValidationError"
}

// Error satisfies the builtin error interface
func (e LoginCheckRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginCheckRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginCheckRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginCheckRequestValidationError{}

// Validate checks the field values on LoginCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoginCheckResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginCheckResponseMultiError, or nil if none found.
func (m *LoginCheckResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginCheckResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginCheckResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginCheckResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginCheckResponseValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetNeededOrEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LoginCheckResponseValidationError{
						field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LoginCheckResponseValidationError{
						field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoginCheckResponseValidationError{
					field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LoginCheckResponseMultiError(errors)
	}

	return nil
}

// LoginCheckResponseMultiError is an error wrapping multiple validation errors
// returned by LoginCheckResponse.ValidateAll() if the designated constraints
// aren't met.
type LoginCheckResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginCheckResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginCheckResponseMultiError) AllErrors() []error { return m }

// LoginCheckResponseValidationError is the validation error returned by
// LoginCheckResponse.Validate if the designated constraints aren't met.
type LoginCheckResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginCheckResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginCheckResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginCheckResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginCheckResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginCheckResponseValidationError) ErrorName() string {
	return "LoginCheckResponseValidationError"
}

// Error satisfies the builtin error interface
func (e LoginCheckResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginCheckResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginCheckResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginCheckResponseValidationError{}

// Validate checks the field values on LoginEndRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LoginEndRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginEndRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginEndRequestMultiError, or nil if none found.
func (m *LoginEndRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginEndRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetBizId()) < 1 {
		err := LoginEndRequestValidationError{
			field:  "BizId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return LoginEndRequestMultiError(errors)
	}

	return nil
}

// LoginEndRequestMultiError is an error wrapping multiple validation errors
// returned by LoginEndRequest.ValidateAll() if the designated constraints
// aren't met.
type LoginEndRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginEndRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginEndRequestMultiError) AllErrors() []error { return m }

// LoginEndRequestValidationError is the validation error returned by
// LoginEndRequest.Validate if the designated constraints aren't met.
type LoginEndRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginEndRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginEndRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginEndRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginEndRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginEndRequestValidationError) ErrorName() string { return "LoginEndRequestValidationError" }

// Error satisfies the builtin error interface
func (e LoginEndRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginEndRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginEndRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginEndRequestValidationError{}

// Validate checks the field values on LoginEndResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LoginEndResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginEndResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginEndResponseMultiError, or nil if none found.
func (m *LoginEndResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginEndResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginEndResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginEndResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginEndResponseValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserId

	// no validation rules for Token

	if len(errors) > 0 {
		return LoginEndResponseMultiError(errors)
	}

	return nil
}

// LoginEndResponseMultiError is an error wrapping multiple validation errors
// returned by LoginEndResponse.ValidateAll() if the designated constraints
// aren't met.
type LoginEndResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginEndResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginEndResponseMultiError) AllErrors() []error { return m }

// LoginEndResponseValidationError is the validation error returned by
// LoginEndResponse.Validate if the designated constraints aren't met.
type LoginEndResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginEndResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginEndResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginEndResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginEndResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginEndResponseValidationError) ErrorName() string { return "LoginEndResponseValidationError" }

// Error satisfies the builtin error interface
func (e LoginEndResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginEndResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginEndResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginEndResponseValidationError{}

// Validate checks the field values on ChangeBeginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChangeBeginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeBeginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangeBeginRequestMultiError, or nil if none found.
func (m *ChangeBeginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeBeginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ChangeBeginRequestMultiError(errors)
	}

	return nil
}

// ChangeBeginRequestMultiError is an error wrapping multiple validation errors
// returned by ChangeBeginRequest.ValidateAll() if the designated constraints
// aren't met.
type ChangeBeginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeBeginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeBeginRequestMultiError) AllErrors() []error { return m }

// ChangeBeginRequestValidationError is the validation error returned by
// ChangeBeginRequest.Validate if the designated constraints aren't met.
type ChangeBeginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeBeginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeBeginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeBeginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeBeginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeBeginRequestValidationError) ErrorName() string {
	return "ChangeBeginRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ChangeBeginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeBeginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeBeginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeBeginRequestValidationError{}

// Validate checks the field values on ChangeBeginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChangeBeginResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeBeginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangeBeginResponseMultiError, or nil if none found.
func (m *ChangeBeginResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeBeginResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeBeginResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeBeginResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeBeginResponseValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BizId

	for idx, item := range m.GetNeededOrEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChangeBeginResponseValidationError{
						field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChangeBeginResponseValidationError{
						field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChangeBeginResponseValidationError{
					field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ChangeBeginResponseMultiError(errors)
	}

	return nil
}

// ChangeBeginResponseMultiError is an error wrapping multiple validation
// errors returned by ChangeBeginResponse.ValidateAll() if the designated
// constraints aren't met.
type ChangeBeginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeBeginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeBeginResponseMultiError) AllErrors() []error { return m }

// ChangeBeginResponseValidationError is the validation error returned by
// ChangeBeginResponse.Validate if the designated constraints aren't met.
type ChangeBeginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeBeginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeBeginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeBeginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeBeginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeBeginResponseValidationError) ErrorName() string {
	return "ChangeBeginResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ChangeBeginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeBeginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeBeginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeBeginResponseValidationError{}

// Validate checks the field values on ChangeCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChangeCheckRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangeCheckRequestMultiError, or nil if none found.
func (m *ChangeCheckRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeCheckRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetBizId()) < 1 {
		err := ChangeCheckRequestValidationError{
			field:  "BizId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ChangeCheckRequestMultiError(errors)
	}

	return nil
}

// ChangeCheckRequestMultiError is an error wrapping multiple validation errors
// returned by ChangeCheckRequest.ValidateAll() if the designated constraints
// aren't met.
type ChangeCheckRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeCheckRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeCheckRequestMultiError) AllErrors() []error { return m }

// ChangeCheckRequestValidationError is the validation error returned by
// ChangeCheckRequest.Validate if the designated constraints aren't met.
type ChangeCheckRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeCheckRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeCheckRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeCheckRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeCheckRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeCheckRequestValidationError) ErrorName() string {
	return "ChangeCheckRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ChangeCheckRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeCheckRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeCheckRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeCheckRequestValidationError{}

// Validate checks the field values on ChangeCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChangeCheckResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangeCheckResponseMultiError, or nil if none found.
func (m *ChangeCheckResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeCheckResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeCheckResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeCheckResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeCheckResponseValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetNeededOrEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChangeCheckResponseValidationError{
						field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChangeCheckResponseValidationError{
						field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChangeCheckResponseValidationError{
					field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ChangeCheckResponseMultiError(errors)
	}

	return nil
}

// ChangeCheckResponseMultiError is an error wrapping multiple validation
// errors returned by ChangeCheckResponse.ValidateAll() if the designated
// constraints aren't met.
type ChangeCheckResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeCheckResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeCheckResponseMultiError) AllErrors() []error { return m }

// ChangeCheckResponseValidationError is the validation error returned by
// ChangeCheckResponse.Validate if the designated constraints aren't met.
type ChangeCheckResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeCheckResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeCheckResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeCheckResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeCheckResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeCheckResponseValidationError) ErrorName() string {
	return "ChangeCheckResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ChangeCheckResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeCheckResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeCheckResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeCheckResponseValidationError{}

// Validate checks the field values on ChangeEndRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ChangeEndRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeEndRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangeEndRequestMultiError, or nil if none found.
func (m *ChangeEndRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeEndRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetBizId()) < 1 {
		err := ChangeEndRequestValidationError{
			field:  "BizId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ChangeEndRequestMultiError(errors)
	}

	return nil
}

// ChangeEndRequestMultiError is an error wrapping multiple validation errors
// returned by ChangeEndRequest.ValidateAll() if the designated constraints
// aren't met.
type ChangeEndRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeEndRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeEndRequestMultiError) AllErrors() []error { return m }

// ChangeEndRequestValidationError is the validation error returned by
// ChangeEndRequest.Validate if the designated constraints aren't met.
type ChangeEndRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeEndRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeEndRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeEndRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeEndRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeEndRequestValidationError) ErrorName() string { return "ChangeEndRequestValidationError" }

// Error satisfies the builtin error interface
func (e ChangeEndRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeEndRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeEndRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeEndRequestValidationError{}

// Validate checks the field values on ChangeEndResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ChangeEndResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeEndResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangeEndResponseMultiError, or nil if none found.
func (m *ChangeEndResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeEndResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeEndResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeEndResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeEndResponseValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ChangeEndResponseMultiError(errors)
	}

	return nil
}

// ChangeEndResponseMultiError is an error wrapping multiple validation errors
// returned by ChangeEndResponse.ValidateAll() if the designated constraints
// aren't met.
type ChangeEndResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeEndResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeEndResponseMultiError) AllErrors() []error { return m }

// ChangeEndResponseValidationError is the validation error returned by
// ChangeEndResponse.Validate if the designated constraints aren't met.
type ChangeEndResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeEndResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeEndResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeEndResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeEndResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeEndResponseValidationError) ErrorName() string {
	return "ChangeEndResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ChangeEndResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeEndResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeEndResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeEndResponseValidationError{}

// Validate checks the field values on DeleteBeginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteBeginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteBeginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteBeginRequestMultiError, or nil if none found.
func (m *DeleteBeginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteBeginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteBeginRequestMultiError(errors)
	}

	return nil
}

// DeleteBeginRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteBeginRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteBeginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBeginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBeginRequestMultiError) AllErrors() []error { return m }

// DeleteBeginRequestValidationError is the validation error returned by
// DeleteBeginRequest.Validate if the designated constraints aren't met.
type DeleteBeginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteBeginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteBeginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteBeginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteBeginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteBeginRequestValidationError) ErrorName() string {
	return "DeleteBeginRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteBeginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteBeginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteBeginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteBeginRequestValidationError{}

// Validate checks the field values on DeleteBeginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteBeginResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteBeginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteBeginResponseMultiError, or nil if none found.
func (m *DeleteBeginResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteBeginResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteBeginResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteBeginResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteBeginResponseValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BizId

	for idx, item := range m.GetNeededOrEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteBeginResponseValidationError{
						field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteBeginResponseValidationError{
						field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteBeginResponseValidationError{
					field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteBeginResponseMultiError(errors)
	}

	return nil
}

// DeleteBeginResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteBeginResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteBeginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBeginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBeginResponseMultiError) AllErrors() []error { return m }

// DeleteBeginResponseValidationError is the validation error returned by
// DeleteBeginResponse.Validate if the designated constraints aren't met.
type DeleteBeginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteBeginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteBeginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteBeginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteBeginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteBeginResponseValidationError) ErrorName() string {
	return "DeleteBeginResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteBeginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteBeginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteBeginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteBeginResponseValidationError{}

// Validate checks the field values on DeleteCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCheckRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCheckRequestMultiError, or nil if none found.
func (m *DeleteCheckRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCheckRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetBizId()) < 1 {
		err := DeleteCheckRequestValidationError{
			field:  "BizId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteCheckRequestMultiError(errors)
	}

	return nil
}

// DeleteCheckRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteCheckRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteCheckRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCheckRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCheckRequestMultiError) AllErrors() []error { return m }

// DeleteCheckRequestValidationError is the validation error returned by
// DeleteCheckRequest.Validate if the designated constraints aren't met.
type DeleteCheckRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCheckRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCheckRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCheckRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCheckRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCheckRequestValidationError) ErrorName() string {
	return "DeleteCheckRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCheckRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCheckRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCheckRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCheckRequestValidationError{}

// Validate checks the field values on DeleteCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCheckResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCheckResponseMultiError, or nil if none found.
func (m *DeleteCheckResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCheckResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteCheckResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteCheckResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteCheckResponseValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetNeededOrEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteCheckResponseValidationError{
						field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteCheckResponseValidationError{
						field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteCheckResponseValidationError{
					field:  fmt.Sprintf("NeededOrEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteCheckResponseMultiError(errors)
	}

	return nil
}

// DeleteCheckResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteCheckResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteCheckResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCheckResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCheckResponseMultiError) AllErrors() []error { return m }

// DeleteCheckResponseValidationError is the validation error returned by
// DeleteCheckResponse.Validate if the designated constraints aren't met.
type DeleteCheckResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCheckResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCheckResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCheckResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCheckResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCheckResponseValidationError) ErrorName() string {
	return "DeleteCheckResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCheckResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCheckResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCheckResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCheckResponseValidationError{}

// Validate checks the field values on DeleteEndRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteEndRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteEndRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteEndRequestMultiError, or nil if none found.
func (m *DeleteEndRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteEndRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetBizId()) < 1 {
		err := DeleteEndRequestValidationError{
			field:  "BizId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteEndRequestMultiError(errors)
	}

	return nil
}

// DeleteEndRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteEndRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteEndRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteEndRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteEndRequestMultiError) AllErrors() []error { return m }

// DeleteEndRequestValidationError is the validation error returned by
// DeleteEndRequest.Validate if the designated constraints aren't met.
type DeleteEndRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteEndRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteEndRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteEndRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteEndRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteEndRequestValidationError) ErrorName() string { return "DeleteEndRequestValidationError" }

// Error satisfies the builtin error interface
func (e DeleteEndRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteEndRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteEndRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteEndRequestValidationError{}

// Validate checks the field values on DeleteEndResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteEndResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteEndResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteEndResponseMultiError, or nil if none found.
func (m *DeleteEndResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteEndResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteEndResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteEndResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteEndResponseValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteEndResponseMultiError(errors)
	}

	return nil
}

// DeleteEndResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteEndResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteEndResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteEndResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteEndResponseMultiError) AllErrors() []error { return m }

// DeleteEndResponseValidationError is the validation error returned by
// DeleteEndResponse.Validate if the designated constraints aren't met.
type DeleteEndResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteEndResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteEndResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteEndResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteEndResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteEndResponseValidationError) ErrorName() string {
	return "DeleteEndResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteEndResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteEndResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteEndResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteEndResponseValidationError{}

// Validate checks the field values on ListUsersRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListUsersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUsersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUsersRequestMultiError, or nil if none found.
func (m *ListUsersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUsersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListUsersRequestMultiError(errors)
	}

	return nil
}

// ListUsersRequestMultiError is an error wrapping multiple validation errors
// returned by ListUsersRequest.ValidateAll() if the designated constraints
// aren't met.
type ListUsersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUsersRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUsersRequestMultiError) AllErrors() []error { return m }

// ListUsersRequestValidationError is the validation error returned by
// ListUsersRequest.Validate if the designated constraints aren't met.
type ListUsersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUsersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUsersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUsersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUsersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUsersRequestValidationError) ErrorName() string { return "ListUsersRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListUsersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUsersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUsersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUsersRequestValidationError{}

// Validate checks the field values on UserInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserInfoMultiError, or nil
// if none found.
func (m *UserInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserName

	// no validation rules for HasGoogle_2Fa

	// no validation rules for Admin

	if len(errors) > 0 {
		return UserInfoMultiError(errors)
	}

	return nil
}

// UserInfoMultiError is an error wrapping multiple validation errors returned
// by UserInfo.ValidateAll() if the designated constraints aren't met.
type UserInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfoMultiError) AllErrors() []error { return m }

// UserInfoValidationError is the validation error returned by
// UserInfo.Validate if the designated constraints aren't met.
type UserInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfoValidationError) ErrorName() string { return "UserInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfoValidationError{}

// Validate checks the field values on ListUsersResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListUsersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUsersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUsersResponseMultiError, or nil if none found.
func (m *ListUsersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUsersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListUsersResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListUsersResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListUsersResponseValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetUserInfos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUsersResponseValidationError{
						field:  fmt.Sprintf("UserInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUsersResponseValidationError{
						field:  fmt.Sprintf("UserInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUsersResponseValidationError{
					field:  fmt.Sprintf("UserInfos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListUsersResponseMultiError(errors)
	}

	return nil
}

// ListUsersResponseMultiError is an error wrapping multiple validation errors
// returned by ListUsersResponse.ValidateAll() if the designated constraints
// aren't met.
type ListUsersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUsersResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUsersResponseMultiError) AllErrors() []error { return m }

// ListUsersResponseValidationError is the validation error returned by
// ListUsersResponse.Validate if the designated constraints aren't met.
type ListUsersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUsersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUsersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUsersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUsersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUsersResponseValidationError) ErrorName() string {
	return "ListUsersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListUsersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUsersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUsersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUsersResponseValidationError{}

// Validate checks the field values on CheckTokenRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CheckTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckTokenRequestMultiError, or nil if none found.
func (m *CheckTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CheckTokenRequestMultiError(errors)
	}

	return nil
}

// CheckTokenRequestMultiError is an error wrapping multiple validation errors
// returned by CheckTokenRequest.ValidateAll() if the designated constraints
// aren't met.
type CheckTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckTokenRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckTokenRequestMultiError) AllErrors() []error { return m }

// CheckTokenRequestValidationError is the validation error returned by
// CheckTokenRequest.Validate if the designated constraints aren't met.
type CheckTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckTokenRequestValidationError) ErrorName() string {
	return "CheckTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckTokenRequestValidationError{}

// Validate checks the field values on UserTokenInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserTokenInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserTokenInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserTokenInfoMultiError, or
// nil if none found.
func (m *UserTokenInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserTokenInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserName

	// no validation rules for StartAt

	// no validation rules for Age

	if len(errors) > 0 {
		return UserTokenInfoMultiError(errors)
	}

	return nil
}

// UserTokenInfoMultiError is an error wrapping multiple validation errors
// returned by UserTokenInfo.ValidateAll() if the designated constraints
// aren't met.
type UserTokenInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserTokenInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserTokenInfoMultiError) AllErrors() []error { return m }

// UserTokenInfoValidationError is the validation error returned by
// UserTokenInfo.Validate if the designated constraints aren't met.
type UserTokenInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserTokenInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserTokenInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserTokenInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserTokenInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserTokenInfoValidationError) ErrorName() string { return "UserTokenInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserTokenInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserTokenInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserTokenInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserTokenInfoValidationError{}

// Validate checks the field values on CheckTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckTokenResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckTokenResponseMultiError, or nil if none found.
func (m *CheckTokenResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckTokenResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckTokenResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckTokenResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckTokenResponseValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTokenInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckTokenResponseValidationError{
					field:  "TokenInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckTokenResponseValidationError{
					field:  "TokenInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTokenInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckTokenResponseValidationError{
				field:  "TokenInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CheckTokenResponseMultiError(errors)
	}

	return nil
}

// CheckTokenResponseMultiError is an error wrapping multiple validation errors
// returned by CheckTokenResponse.ValidateAll() if the designated constraints
// aren't met.
type CheckTokenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckTokenResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckTokenResponseMultiError) AllErrors() []error { return m }

// CheckTokenResponseValidationError is the validation error returned by
// CheckTokenResponse.Validate if the designated constraints aren't met.
type CheckTokenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckTokenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckTokenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckTokenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckTokenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckTokenResponseValidationError) ErrorName() string {
	return "CheckTokenResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CheckTokenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckTokenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckTokenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckTokenResponseValidationError{}

// Validate checks the field values on RenewTokenRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RenewTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RenewTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RenewTokenRequestMultiError, or nil if none found.
func (m *RenewTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RenewTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RenewTokenRequestMultiError(errors)
	}

	return nil
}

// RenewTokenRequestMultiError is an error wrapping multiple validation errors
// returned by RenewTokenRequest.ValidateAll() if the designated constraints
// aren't met.
type RenewTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RenewTokenRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RenewTokenRequestMultiError) AllErrors() []error { return m }

// RenewTokenRequestValidationError is the validation error returned by
// RenewTokenRequest.Validate if the designated constraints aren't met.
type RenewTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RenewTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RenewTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RenewTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RenewTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RenewTokenRequestValidationError) ErrorName() string {
	return "RenewTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RenewTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRenewTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RenewTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RenewTokenRequestValidationError{}

// Validate checks the field values on RenewTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RenewTokenResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RenewTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RenewTokenResponseMultiError, or nil if none found.
func (m *RenewTokenResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RenewTokenResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RenewTokenResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RenewTokenResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RenewTokenResponseValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NewToken

	if all {
		switch v := interface{}(m.GetTokenInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RenewTokenResponseValidationError{
					field:  "TokenInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RenewTokenResponseValidationError{
					field:  "TokenInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTokenInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RenewTokenResponseValidationError{
				field:  "TokenInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RenewTokenResponseMultiError(errors)
	}

	return nil
}

// RenewTokenResponseMultiError is an error wrapping multiple validation errors
// returned by RenewTokenResponse.ValidateAll() if the designated constraints
// aren't met.
type RenewTokenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RenewTokenResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RenewTokenResponseMultiError) AllErrors() []error { return m }

// RenewTokenResponseValidationError is the validation error returned by
// RenewTokenResponse.Validate if the designated constraints aren't met.
type RenewTokenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RenewTokenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RenewTokenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RenewTokenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RenewTokenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RenewTokenResponseValidationError) ErrorName() string {
	return "RenewTokenResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RenewTokenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRenewTokenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RenewTokenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RenewTokenResponseValidationError{}

// Validate checks the field values on LogoutRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogoutRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogoutRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LogoutRequestMultiError, or
// nil if none found.
func (m *LogoutRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LogoutRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return LogoutRequestMultiError(errors)
	}

	return nil
}

// LogoutRequestMultiError is an error wrapping multiple validation errors
// returned by LogoutRequest.ValidateAll() if the designated constraints
// aren't met.
type LogoutRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogoutRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogoutRequestMultiError) AllErrors() []error { return m }

// LogoutRequestValidationError is the validation error returned by
// LogoutRequest.Validate if the designated constraints aren't met.
type LogoutRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogoutRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogoutRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogoutRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogoutRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogoutRequestValidationError) ErrorName() string { return "LogoutRequestValidationError" }

// Error satisfies the builtin error interface
func (e LogoutRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogoutRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogoutRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogoutRequestValidationError{}

// Validate checks the field values on LogoutResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogoutResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogoutResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LogoutResponseMultiError,
// or nil if none found.
func (m *LogoutResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LogoutResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogoutResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogoutResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogoutResponseValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LogoutResponseMultiError(errors)
	}

	return nil
}

// LogoutResponseMultiError is an error wrapping multiple validation errors
// returned by LogoutResponse.ValidateAll() if the designated constraints
// aren't met.
type LogoutResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogoutResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogoutResponseMultiError) AllErrors() []error { return m }

// LogoutResponseValidationError is the validation error returned by
// LogoutResponse.Validate if the designated constraints aren't met.
type LogoutResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogoutResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogoutResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogoutResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogoutResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogoutResponseValidationError) ErrorName() string { return "LogoutResponseValidationError" }

// Error satisfies the builtin error interface
func (e LogoutResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogoutResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogoutResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogoutResponseValidationError{}
